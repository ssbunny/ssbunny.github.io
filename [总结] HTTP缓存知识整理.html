
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <!-- common.css -->
      <style>* {-webkit-tap-highlight-color: rgba(0,0,0,0);}html {-webkit-text-size-adjust: none;}body {font-family: -apple-system, Helvetica, Arial, sans-serif;margin: 0;padding: 20px;color: #333;word-wrap: break-word;}h1, h2, h3, h4, h5, h6 {line-height: 1.1;}img {max-width: 100% !important;height: auto;}blockquote {margin: 0;padding: 0 15px;color: #777;border-left: 4px solid #ddd;}hr {background-color: #ddd;border: 0;height: 1px;margin: 15px 0;}code {font-family: Menlo, Consolas, 'Ubuntu Mono', Monaco, 'source-code-pro', monospace;line-height: 1.4;margin: 0;padding: 0.2em 0;font-size: 90%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}pre > code {margin: 0;padding: 0;font-size: 100%;word-break: normal;background: transparent;border: 0;}ol {list-style-type: decimal;}ol ol, ul ol {list-style-type: lower-latin;}ol ol ol, ul ol ol, ul ul ol, ol ul ol {list-style-type: lower-roman;}table {border-spacing: 0;border-collapse: collapse;margin-top: 0;margin-bottom: 16px;}table th {font-weight: bold;}table th, table td {padding: 6px 13px;border: 1px solid #ddd;}table tr {border-top: 1px solid #ccc;}table tr:nth-child(even) {background-color: #f8f8f8;}input[type="checkbox"] {cursor: default;margin-right: 0.5em;font-size: 13px;}.task-list-item {list-style-type: none;}.task-list-item+.task-list-item {margin-top: 3px;}.task-list-item input {float: left;margin: 0.3em 1em 0.25em -1.6em;vertical-align: middle;}#tag-field {margin: 8px 2px 10px;}#tag-field .tag {display: inline-block;background: #cadff3;border-radius: 4px;padding: 1px 8px;color: black;font-size: 12px;margin-right: 10px;line-height: 1.4;}</style>
      <!-- ace-static.css -->
      <style>.ace_static_highlight {white-space: pre-wrap;}.ace_static_highlight .ace_gutter {width: 2em;text-align: right;padding: 0 3px 0 0;margin-right: 3px;}.ace_static_highlight.ace_show_gutter > .ace_line {padding-left: 2.6em;}.ace_static_highlight .ace_line {position: relative;}.ace_static_highlight .ace_gutter-cell {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;top: 0;bottom: 0;left: 0;position: absolute;}.ace_static_highlight .ace_gutter-cell:before {content: counter(ace_line, decimal);counter-increment: ace_line;}.ace_static_highlight {counter-reset: ace_line;}</style>
      <style>.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>
      <!-- export.css -->
      <style>
        body{margin:0 auto;max-width:800px;line-height:1.4}
        #nav{margin:5px 0 10px;font-size:15px}
        #titlearea{border-bottom:1px solid #ccc;font-size:17px;padding:10px 0;}
        #contentarea{font-size:15px;margin:16px 0}
        .cell{outline:0;min-height:20px;margin:5px 0;padding:5px 0;}
        .code-cell{font-family:Menlo,Consolas,'Ubuntu Mono',Monaco,'source-code-pro',monospace;font-size:12px;}
        .latex-cell{white-space:pre-wrap;}
      </style>
      <!-- User CSS -->
      <style> .text-cell {font-size: 15px;}.code-cell {font-size: 12px;}.markdown-cell {font-size: 15px;}.latex-cell {font-size: 15px;}</style>
    </head>
    <body>
      <div id="nav"><div>Next: <a href='[总结] CSS 布局技巧.html'>[总结] CSS 布局技巧</a>, Previous: <a href='[总结] Java8 之 Lambda 表达式.html'>[总结] Java8 之 Lambda 表达式</a>, Up: <a href='index.html'>Index</a></div></div>
      <div id="titlearea">
        <h2>[总结] HTTP缓存知识整理</h2>
      </div>
      <div id="contentarea"><div class="cell markdown-cell"><p>做一下 HTTP 缓存相关知识点的总结。</p>
<h2>1. 缓存命中</h2>
<p>关于命中的概念如下：</p>
<ul>
<li><strong>缓存命中（cache hit）</strong> 用已有的副本为某些到达缓存的请求提供服务。</li>
<li><strong>缓存未命中（cache miss）</strong> 一些到达缓存的请求由于没有副本可用，而被转发给原始服务器。</li>
<li><strong>再验证（revalidation）</strong> 原始服务器的内容可能发生变化，缓存要不时检测其副本是否是服务器上最新的副本。</li>
<li><strong>再验证命中/缓慢命中（revalidation hit / slow hit）</strong> 缓存对其副本进行再验证时， 会向原始服务器发起一个小的再验证请求，如果服务器返回304缓存再次将副本标识为新鲜的。 缓慢命中要比缓存命中慢，比缓存未命中快。</li>
</ul>
<p>考量命中率主要有两种方式：</p>
<ul>
<li><strong>缓存命中率</strong> 由缓存提供服务的请求所占的比例。对现在中等规模的缓存，40%的命中率是合理的。</li>
<li><strong>字节命中率</strong> 缓存提供的字节在传输的所有字节中所占的比例。</li>
</ul>
<h2>2. 处理过程</h2>
<p><img src="resources/355FC267475DC7C0F5EAFACF9B3A4D40.jpg" alt="IMAGE" width="1500" height="1162"></p>
<h2>3. 再验证</h2>
<p>相关的 5 个条件首部：</p>
<ul>
<li><code>If-Modified-Since</code> ：通过比较过期日期进行再验证。</li>
<li><code>If-None-Match</code> ：通过比较实体标签(ETag)进行再验证。</li>
<li><code>If-Unmodified-Since</code> ：在进行部分文件的传输时，获取文件的其余部分之前用来确保文件未发生变化。</li>
<li><code>If-Range</code> ：支持对不完整文档的缓存。</li>
<li><code>If-Match</code> ：用于与Web服务器打交道时的并发控制。</li>
</ul>
<p>IMS请求：<code>If-Modified-Since</code> 再验证请求。只有自某个日期之后资源发生了变化的时候，IMS请求才会执行：返回新文档给缓存或304，以及新的过期日期。有些Web服务器只是将IMS日期和文档最后修改日期进行字符串比较。</p>
<p>强弱验证器：只要内容发生变化，强验证器就会变化；内容的主要含义发生变化时，弱验证器会变化。服务器会用 <code>W/</code> 前缀来标识弱验证器。</p>
<pre><div class="ace-chrome"><div class="ace_static_highlight ace_show_gutter" style="counter-reset:ace_line 0"><div class="ace_line"><span class="ace_gutter ace_gutter-cell" unselectable="on"></span>ETag: W/"v2.6"
</div><div class="ace_line"><span class="ace_gutter ace_gutter-cell" unselectable="on"></span>If-None-Match: W/"v2.6"
</div></div></div></pre>
<p>如果服务器回送了一个 <code>ETag</code> ，HTTP1.1客户端就必须使用实体标签验证器。如果服务器只回送一个 <code>Last-Modified</code> 值，客户端就可以使用 <code>If-Modified-Since</code> 验证。如果两种方式都提供，客户端应该使用两种再验证方式。</p>
<h2>4. 控制缓存</h2>
<ul>
<li><strong>Cache-Control: no-store</strong> ：禁止缓存对响应进行复制。缓存会像非缓存代理服务器一样，像客户端发送一条 no-store 响应，然后删除对象。</li>
<li><strong>Cache-Control: no-cache</strong> ：响应可以存储在本地缓存区中。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。</li>
<li><strong>Pragma: no-cache</strong> ：兼容HTTP1.0+</li>
<li><strong>Cache-Control: max-age</strong> ：从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数。 <code>s-maxage</code> 表示仅适用于公有缓存。服务器可以将最大使用期设置为 0 ，从而在每次访问时都刷新。<br>
Cache-Control: max-age=3600<br>
Cache-Control: s-maxage=3600</li>
<li><strong>Expires</strong> ：(不推荐使用) 指定实际的过期日期。HTTP设计者后来认为服务器时钟不同步或不正确，<br>
所以最好还是使用剩余秒数来表示过期时间。</li>
<li><strong>Cache-Control: must-revalidate</strong> ：缓存在事先没有跟原始服务器进行再验证的情况下，<br>
不能提供对象的陈旧副本。如果缓存进行新鲜度检查时原始服务器不可用，缓存必须返回504错误。</li>
<li><strong>试探性过期</strong> ：缓存可以计算出一个试探性最大使用期。<em>LM-Factor算法</em></li>
</ul>
<p><strong>附表： Cache-Control</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control: max-stale</td>
<td>缓存可以随意提供过期文件(放松缓存规则)</td>
</tr>
<tr>
<td>Cache-Control: max-stale=s</td>
<td>在时间 s 秒内，文档不能过期</td>
</tr>
<tr>
<td>Cache-Control: min-fresh=s</td>
<td>至少在未来 s 秒内文档要保持新鲜(严格规则)</td>
</tr>
<tr>
<td>Cache-Control: max-age=s</td>
<td>缓存无法返回缓存时间长于 s 秒的文档(严格规则)</td>
</tr>
<tr>
<td>Cache-Control: no-cache</td>
<td>除非资源进行了再验证，否则客户端不接受已缓存的资源</td>
</tr>
<tr>
<td>Pragma: no-cache</td>
<td>HTTP/1.0+ 同上</td>
</tr>
<tr>
<td>Cache-Control: no-store</td>
<td>缓存应该尽快从存储器中删除文档的所有痕迹</td>
</tr>
<tr>
<td>Cache-Control: only-if-cached</td>
<td>只有当缓存中有副本存在时，客户端才会获取一份副本</td>
</tr>
</tbody>
</table>
<p><em>主要参考资料：《HTTP权威指南》</em></p>
</div></div>
      <script>document.body.onkeyup = function(e) {
if (e.keyCode === 39) window.location.href = '[总结] CSS 布局技巧.html';
if (e.keyCode === 37) window.location.href = '[总结] Java8 之 Lambda 表达式.html';
}</script>
    </body>
    </html>
  