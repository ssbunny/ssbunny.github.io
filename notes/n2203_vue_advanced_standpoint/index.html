<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.35">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/favicon.ico"><title>高观点下的 Vue.js 框架 | 兔子不咬人</title><meta name="description" content="我的个人空间">
    <link rel="modulepreload" href="/assets/app.75c5ff89.js"><link rel="modulepreload" href="/assets/index.html.3aac3728.js"><link rel="modulepreload" href="/assets/index.html.d0b2b9a3.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/assets/style.cdb4f165.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="切换侧边栏" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/images/home_bug.svg" alt="兔子不咬人"><span class="site-name can-hide">兔子不咬人</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/notes" class="router-link-active" aria-label="技术文章"><!--[--><!--]--> 技术文章 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="实验室"><span class="title">实验室</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="实验室"><span class="title">实验室</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/lab/css_layout_flexbox" class="" aria-label="CSS Flex 布局"><!--[--><!--]--> CSS Flex 布局 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/lab/css_layout_grid" class="" aria-label="CSS Grid 布局"><!--[--><!--]--> CSS Grid 布局 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/lab/web-demo" class="" aria-label="Web 特效演示"><!--[--><!--]--> Web 特效演示 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="常用链接"><span class="title">常用链接</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="常用链接"><span class="title">常用链接</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://pythontutor.com/visualize.html#mode=edit" rel="noopener noreferrer" target="_blank" aria-label="代码执行过程可视化"><!--[--><!--]--> 代码执行过程可视化 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://latex.codecogs.com/" rel="noopener noreferrer" target="_blank" aria-label="latex 公式编辑器"><!--[--><!--]--> latex 公式编辑器 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://asciiflow.com/#/" rel="noopener noreferrer" target="_blank" aria-label="ascii 流程图"><!--[--><!--]--> ascii 流程图 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="http://patorjk.com/software/taag" rel="noopener noreferrer" target="_blank" aria-label="ascii art 生成"><!--[--><!--]--> ascii art 生成 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/ssbunny" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="切换夜间模式"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/notes" class="router-link-active" aria-label="技术文章"><!--[--><!--]--> 技术文章 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="实验室"><span class="title">实验室</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="实验室"><span class="title">实验室</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/lab/css_layout_flexbox" class="" aria-label="CSS Flex 布局"><!--[--><!--]--> CSS Flex 布局 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/lab/css_layout_grid" class="" aria-label="CSS Grid 布局"><!--[--><!--]--> CSS Grid 布局 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/lab/web-demo" class="" aria-label="Web 特效演示"><!--[--><!--]--> Web 特效演示 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="常用链接"><span class="title">常用链接</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="常用链接"><span class="title">常用链接</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a class="external-link" href="https://pythontutor.com/visualize.html#mode=edit" rel="noopener noreferrer" target="_blank" aria-label="代码执行过程可视化"><!--[--><!--]--> 代码执行过程可视化 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://latex.codecogs.com/" rel="noopener noreferrer" target="_blank" aria-label="latex 公式编辑器"><!--[--><!--]--> latex 公式编辑器 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://asciiflow.com/#/" rel="noopener noreferrer" target="_blank" aria-label="ascii 流程图"><!--[--><!--]--> ascii 流程图 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="http://patorjk.com/software/taag" rel="noopener noreferrer" target="_blank" aria-label="ascii art 生成"><!--[--><!--]--> ascii art 生成 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/ssbunny" rel="noopener noreferrer" target="_blank" aria-label="GitHub"><!--[--><!--]--> GitHub <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">在新窗口打开</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">高观点下的 Vue.js 框架 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#鸟瞰" class="router-link-active router-link-exact-active sidebar-item" aria-label="鸟瞰"><!--[--><!--]--> 鸟瞰 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#响应系统" class="router-link-active router-link-exact-active sidebar-item" aria-label="响应系统"><!--[--><!--]--> 响应系统 <!--[--><!--]--></a><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#设计思路" class="router-link-active router-link-exact-active sidebar-item" aria-label="设计思路"><!--[--><!--]--> 设计思路 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#技术实现" class="router-link-active router-link-exact-active sidebar-item" aria-label="技术实现"><!--[--><!--]--> 技术实现 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#边界情况" class="router-link-active router-link-exact-active sidebar-item" aria-label="边界情况"><!--[--><!--]--> 边界情况 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#api-设计" class="router-link-active router-link-exact-active sidebar-item" aria-label="API 设计"><!--[--><!--]--> API 设计 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#渲染器" class="router-link-active router-link-exact-active sidebar-item" aria-label="渲染器"><!--[--><!--]--> 渲染器 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#组件系统" class="router-link-active router-link-exact-active sidebar-item" aria-label="组件系统"><!--[--><!--]--> 组件系统 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/notes/n2203_vue_advanced_standpoint/#编译器" class="router-link-active router-link-exact-active sidebar-item" aria-label="编译器"><!--[--><!--]--> 编译器 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="高观点下的-vue-js-框架" tabindex="-1"><a class="header-anchor" href="#高观点下的-vue-js-框架" aria-hidden="true">#</a> 高观点下的 Vue.js 框架</h1><p>本文是我在学习、使用 Vue.js 过程中的一些个人观点，有些观点仅为我个人的推测，故难免有纰漏甚至偏颇。所谓高观点，只是希望 Standpoint 尽可能高一些，从设计层面看待 Vue.js 这样一个框架，而不陷入具体的 API 讲解或源代码分析中，另外，也是为文章标题赢得一些噱头而已。</p><hr><p>Web 前端编程最本质的工作内容其实仅有两条：</p><ol><li>处理数据</li><li>更新 DOM</li></ol><p>这里的“更新”当然包括首次加载、新增和删除 DOM 。DOM 被更新了，剩下的渲染、绘制过程均由浏览器完成。一直以来，我们的编程工作也是围绕这两件事展开。然而事情的细枝末节太多，繁琐的业务场景让代码量日增，我们的编码方式本身也亟需改进。第一次大变革自然是 jQuery 这类聚焦于“更新 DOM”的库或框架，它们帮我们消除浏览器差异、提供更便利的 API 等。第二次大变革则是前端的全面 MVC 化。</p><p>前端 MVC 历经了 <code>MVC --&gt; MVP --&gt; MVVM</code> 的过程，这里不去述说它的历史。现在我们说到前端 MVC , 说的是它的变种：<strong>MVVM</strong> 。而 Vue.js ，不论官方将其描述得如何高大上，其本质仍只是 MVVM 框架。</p><p>现在来细想 MVVM ，其中 M 为模型（Model），在前端其存在形式只可能是 JavaScript 对象——不管是语言层面最直接的 JavaScript 对象，还是经过一番折腾后封装的 JavaScript 对象——似乎无大可为，只能依赖 JavaScript 解释器来做更多的事情。而对 JavaScript 这样一种动态弱类型语言，模型过分地“充血”似乎也不妥。第二个字母 V 为视图（View），它就是我们所更新的那个 “DOM”，这一切都交由浏览器处理。似乎只有在它们中间放个夹层才能做些大事，这便是 VM ，视图模型层。</p><p>至此，我们在“数据”和“DOM”间建立了桥梁。</p><h2 id="鸟瞰" tabindex="-1"><a class="header-anchor" href="#鸟瞰" aria-hidden="true">#</a> 鸟瞰</h2><p>统观 Vue.js 框架，它所放置的这个夹层，便是被叫作 <strong>“虚拟 DOM”</strong> 的东西。其它一切围绕它展开：</p><p><img src="/assets/vdom.395607d1.svg" alt="vdom"></p><p>我想，Vue.js 所面临的第一个决策便是其所采用的编程范式是“命令式”还是“声明式”的。<strong>声明式</strong>显然在用户层面有其优势，用户代码只需要关注视图最终结果。不管结果存在几种状态，只需要通过某种方式（如 Vue.js 的模板）描述出来。实现声明式后，模型层的数据应当自动流经虚拟 DOM 进而进入真实 DOM 。</p><p>因此，框架中需要一个功能模块，用它来监听用户数据的变化，继而更新虚拟 DOM。这样一来，在引擎层面引入的该功能模块使得用户代码仅为处理数据，而不需要直接与虚拟 DOM 打交道。能够自动捕获用户数据变化并更新虚拟 DOM 的功能模块便是学习 Vue.js 的开发人员最为熟知的<strong>响应系统</strong>：</p><p><img src="/assets/reactive.6c17c732.svg" alt="reactive"></p><p><strong>响应系统是用户代码进入框架引擎的发端。</strong> 如果从一开始便是可响应的，后续引擎中引入的一切功能，便有了“自动”执行的可能。另一方面我们清醒地知道，程序并没有那么多所谓的“自动”，总归是要存在一个触发点的。而响应系统的触发，直接面向 JavaScript 语言层面的对象修改、删除或数组、集合的增删改等操作。这样一个大的观察者模式的被观察对象直接是语言层面最原始的东西，这可能让很多不熟悉语言规范的人感到陌生而神奇，此点后文详说。</p><p>有了虚拟 DOM 这个夹层后，很多事情便有了切入点，方便框架施展手脚。然而虚拟 DOM 是不能被浏览器识别并渲染成可视的界面的。在虚拟 DOM 与真实 DOM 之间必然要存在一层转换机制，这便是<strong>渲染器</strong>，渲染器本质是把虚拟 DOM 这种静态的描述，变成对真实 DOM 的挂载、卸载与更新等操作。</p><p><img src="/assets/renderer.b0448aaa.svg" alt="renderer"></p><p>至此，一个完整的声明式的框架系统便可以工作了。然而我们更进一步来看，模型层的数据可以直接使用语言层面的 JavaScript 对象，框架没入侵我们的编码习惯，没有要求我们遵从特殊的约定写代码（这是响应系统的功劳）。而视图层面呢？从我们熟知的 DOM 变成了一个叫“虚拟 DOM”的东西。可我们还不知道虚拟 DOM 究竟是什么。现在有必要揭开虚拟 DOM 的面纱。</p><p>其实，它只是一个用来描述真实 DOM 的 JavaScript 对象。举个例子便可知，如真实 DOM 结构：</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>foo<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>bar<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对应的虚拟 DOM 为：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> vnodeDiv <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
		<span class="token literal-property property">id</span><span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token literal-property property">children</span><span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>整个 Vue.js 框架居然是围绕这么一个简单的东西在运作，想起来有些微妙。</p><p>现在回到刚才的问题，视图层如何表示？当应用系统需求复杂后，这种 JavaScript 对象的表示方式显然过于丑陋（用过 ExtJS 等框架的开发者显然了解这种方式的痛苦所在）。Vue.js 框架的设计者想让开发者的使用体验回归到编写 HTML 的方式，这是一个很好的设想，如何实现呢？</p><p><img src="/assets/html2vdom.23b9d6d6.svg" alt="html2vdom"></p><p>经验非常自然地告诉我们，此处需要一个<strong>编译器</strong>，用它来架起 HTML 和虚拟 DOM 的桥梁，将用户写的 HTML 翻译成虚拟 DOM。值得注意的是，此处的 HTML 已不再是直接交给浏览器解析的 HTML，而只是借鉴了它的语法形式，本质上只是一些字符串而已。既然决定引入编译器这种复杂的结构，对于这个形如 HTML 的字符串，何不做做手脚让它更为丰富呢？于是框架设计者建立了一套<strong>模板</strong>系统，可以用它扩展 HTML 的语法。</p><p><img src="/assets/template_compiler.01f1fc97.svg" alt="template_compiler"></p><p>现在还有两个小问题未解决，它们在框架架构上是小问题，在用户使用上却至关重要。第一个问题是如何让 HTML 灵动起来。例如如何重复书写 100 遍 <code>div</code> ，如何在特定条件下输出某 <code>span</code> ？HTML 并不是图灵完备的语言，而 JavaScript 却是，虚拟 DOM 刚好也是用 JavaScript 表示。那么，如果用一个 JavaScript 函数来输出虚拟 DOM，而编译器的编译目标不再是虚拟 DOM，改为这个函数，问题便可迎刃而解。</p><p><img src="/assets/render.a051133c.svg" alt="render"></p><p>这便是<strong>渲染函数</strong>在框架中存在的位置及其存在的最根本意义。当虚拟 DOM 的存在形式从普通对象上升为函数，一切便“灵动”起来。函数中使用 <code>for</code> 或者 <code>if</code> 语句，可以解决我们刚才提出的问题。</p><p>第二个小问题。庞大的应用系统中，势必存在繁多的虚拟 DOM ，如何维持其秩序？最简单的方式当然是把这个出力不讨好的活交给开发者本人。Vue.js 框架层面只给开发者提供管理制度，具体的管理方式让其用户（即开发者）自行决定。这套管理制度被叫作<strong>组件系统</strong>。所谓组件系统，本质上是针对虚拟 DOM 进行的打包捆绑方式。我们已经知道了虚拟 DOM 的样貌，在此不妨也来看看组件的样貌（注意，这不是 Vue.js API 层面的组件形式）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">,</span>
	<span class="token literal-property property">myProperty</span><span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">,</span>
	<span class="token operator">...</span>
	<span class="token function">render</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">{</span>
			<span class="token literal-property property">tag</span><span class="token operator">:</span> <span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>
			<span class="token operator">...</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>可以看到，只要组件里包含一个渲染函数（示例中的 <code>render</code>），它便可以通过渲染函数成为一个或一组虚拟 DOM 。而组件对象本身则可以在渲染函数之外附加更多的属性或其它处理函数。这样一来，我们通过提供渲染函数把一组虚拟 DOM 进行打包，附加的属性则像这个包裹上贴的标签一样，描述了这组虚拟 DOM 的特征，让它们成为一个共同体，与其它组件合作构成整个应用系统。由于组件的组织方式交给了用户，我们经常可以看到卓越的程序员封装出卓越的组件库，低劣程序员写的组件却支离破碎。</p><p>至此，我们围绕着虚拟 DOM 完成了 Vue.js 框架的全部顶层设计。用户侧模型层的代码，围绕语言层面最普通的 JavaScript 对象展开，而视图层的代码，聚焦在一种类似 HTML 的模板中。</p><p><img src="/assets/overview.8eaf3e00.svg" alt="overview"></p><p>等等！也就是说虚拟 DOM 在 MVVM 框架中是不可或缺的吗？并非如此。可以看到，响应系统完全可能直接工作于真实 DOM 之上，而编译器也可以直接编译出真实 DOM 。事实上确实也有其它框架在这么做。这中间夹杂了诸多性能、易用性各方面的问题，而 Vue.js 大概是一种稳妥折中的决策结果吧。</p><h2 id="响应系统" tabindex="-1"><a class="header-anchor" href="#响应系统" aria-hidden="true">#</a> 响应系统</h2><p>现在更近一步来思考响应系统。响应系统是网络上资料最为繁多的一部分。有诸多文章甚至以“深入 Vue 原理”之名，内容却只讲了 <code>Object.defineProperty</code> 的用法，再写个示例代码便结束。我这里自然不去讨论 JavaScript 的语法细节，只看响应系统的设计思路。</p><h3 id="设计思路" tabindex="-1"><a class="header-anchor" href="#设计思路" aria-hidden="true">#</a> 设计思路</h3><p>有必要先弄清楚根本目标：<strong>响应系统是为了实现用户模型层数据到视图层界面的声明式编程。</strong> 思考 Vue.js 的工作方式，或者说 Web 前端开发的工作方式：首先拿到用户数据，然后使用数据挂载页面，这是初次加载的情况。后续界面操作进行过程中，数据产生变动，拿到最新的用户数据，更新或卸载页面。</p><p>产生响应的重点，显然是后续数据更新的过程。Vue.js 的设计者并没有其它更高明的办法，他使用的是我们很容易想到的观察者模式——观察数据，通知视图。观察者 Observer 时刻关心响应式数据的变化，一有变化便通知更新视图（通过渲染器完成）。其接口中应该包含用于调用渲染器以更新视图的方法，这里遵从 Vue3 的命名，叫它 <code>effect</code> 函数。 <strong>唯一特殊的一点是，</strong> 注册观察者的过程似乎不需要用户来执行，是否可以在挂载页面或者说是首次执行 <code>effect</code> 时进行注册呢？答案是肯定的。<code>effect</code> 函数内部势必会去获取用来渲染视图的数据，如果在获取数据的时候注册观察者，后面修改数据的时候便可以通知观察者，即执行 <code>effect</code> 函数。此时我们引入一个存放 <code>effect</code> 函数的桶:</p><p><img src="/assets/reactive1.f2613927.svg" alt="reactive1"></p><p>示例代码如下，请先忽略代码可能产生的 BUG，仅关心其所蕴含的调用关系：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">function</span> <span class="token function">effect</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">requestData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment">// 获取数据,用于后续更新视图</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">requestData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>  <span class="token comment">// 注册观察者，即 effect 函数</span>
	<span class="token keyword">return</span> data
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">updateData</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 更新数据时通知观察者，即重新执行 effect 函数</span>
	arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">effect</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
		<span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	data <span class="token operator">=</span> val
<span class="token punctuation">}</span>
<span class="token function">updateData</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>现在聚焦“读取数据”和“更新数据”操作。可以对其进行封装。使用代理模式，从模型层面为原始数据提供代理对象：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">DemoProxy</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>raw <span class="token operator">=</span> data
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token function">requestData</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token function">updateData</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token comment">// ...</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemoProxy</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
data<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span><span class="token string">&#39;123&#39;</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>而 JavaScript 在语言层面，提供了一个函数对象 <code>Proxy</code> 用于代理（ECMAScript 2015 开始提供，在此之前可以使用 Object.defineProperty 实现类似效果），使用它可以实现语言层面的代理，从而用户侧代码不需要调用形如 <code>updateData()</code> 的函数，而是可以直接进行赋值，如 <code>data.foo = &#39;bar&#39;</code>。 只是有一点要保持清醒，代理后的 data 并非用户一开始提供的那个 data , 对它的任何操作都可能被进行了拦截。另外也可以看出，即便 JavaScript 语言层面不提供 <code>Object.defineProperty </code> 或 <code>Proxy</code> ，框架仍然可能实现响应系统，只是用户侧代码相对约束会多一些。</p><p>可以看出， <strong>响应系统在设计层面极其简单：代理模式 + 观察者模式。</strong> 代理普通 JavaScript 对象，调用 effect 函数从而触发对象读取操作，读取操作的代理方法中注册 effect 函数作为观察者，之后当对象产生更新操作时，执行 effect 函数从而促使后续视图层重新渲染。</p><h3 id="技术实现" tabindex="-1"><a class="header-anchor" href="#技术实现" aria-hidden="true">#</a> 技术实现</h3><p>使用 <code>Proxy</code> 是无法处理原始值的。如 String、Number、Symbol、null 等，它们只传值而不传引用。此特殊情况下，Vue.js 框架引入了特殊的函数 <code>ref</code> 。该函数的原理是给原始值包裹一层对象。当然用户可以自己来包裹对象，但使用 <code>ref</code> 的方式更为统一，更为要紧的是让框架知道用户的意图是将原始值转为可响应的代理对象，如此框架便可以在特定的场合帮助用户自动脱去这层包裹，让代码看起来更为优雅。阅读 Refs 相关的一组 API 文档可知，它还会额外处理响应丢失的问题。</p><p><code>Proxy</code> 在代理对象、数组、Map、Set 时， <strong>主要通过拦截相应内置方法，</strong> 如 <code>foo.bar</code> 操作对应着内置方法 <code>[[Get]]</code> ，API 层面叫作 <code>get</code> ，相应的还有 <code>set</code> 、 <code>has</code> 、<code>deleteProperty</code> 等等。通过查阅 JavaScript 语言规范我们可以知道所有语法细节并处理所有可能产生响应的操作。这是一个非常细碎的工作，框架应该已经帮我们处理过了，但面对庞杂的语言细节，也许在某个角落还存在某个特殊的 BUG 为框架所未及。但要相信，Vue.js 框架确实已经考虑得相当周全了，比如这些情况：</p><p>当 <code>effect</code> 函数使用 <code>for...in</code> 访问对象时，对对象属性的增删改操作要被响应；当使用 <code>find</code> 、<code>map</code> 、<code>forEach</code>等方法访问数组时，对数组元素的操作要能够被响应；当获取从原型链中继承的属性时，要正确处理响应等等。</p><h3 id="边界情况" tabindex="-1"><a class="header-anchor" href="#边界情况" aria-hidden="true">#</a> 边界情况</h3><p>响应系统中有很多边界情况要考虑。比如分支切换问题：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> obj<span class="token punctuation">.</span>isFoo <span class="token operator">?</span> obj<span class="token punctuation">.</span>foo <span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>分支切换可能使 <code>effect</code> 函数被遗留。又如 <code>effect</code> 函数的嵌套问题，可以使用 stack 结构解决。另外还有无限递归、循环等问题。</p><p>另外有一种情况，当用户执行了修改数据的操作但数据却没有变化：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span>
foo <span class="token operator">=</span> <span class="token string">&#39;fo&#39;</span> <span class="token operator">+</span> <span class="token string">&#39;o&#39;</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>此时是不应该再触发响应的。这些边界情况的处理都属于框架细节，此文不深入讨论，但我们应该感受到，一个完善的框架要考虑的问题确实很多。</p><h3 id="api-设计" tabindex="-1"><a class="header-anchor" href="#api-设计" aria-hidden="true">#</a> API 设计</h3><p>基于响应系统的 API ，为了其灵活性，框架设计实现了计算属性与 watch ，其实质为 <code>effect</code> 函数的二次封装。另外由于响应存在响应深度的问题，API 提供了深响应和浅响应两种方式。相应的，对于只取数据提供深只读和浅只读。</p><h2 id="渲染器" tabindex="-1"><a class="header-anchor" href="#渲染器" aria-hidden="true">#</a> 渲染器</h2><p>TODO</p><h2 id="组件系统" tabindex="-1"><a class="header-anchor" href="#组件系统" aria-hidden="true">#</a> 组件系统</h2><h2 id="编译器" tabindex="-1"><a class="header-anchor" href="#编译器" aria-hidden="true">#</a> 编译器</h2><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: qqbunny@yeah.net">ssbunny</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.75c5ff89.js" defer></script>
  </body>
</html>
